# RefactorMindMap

## Introduction
重构：改善既有代码的设计    第一版以OOP为主    
针对书本的核心部分6-11章做了思维导图可视化。     
突然发现第二版上个月上市，直接下单了精装版，把这个坑填完我就自己去读第二版了哈哈    

## Link

https://www.processon.com/view/link/5cb5262ee4b059e209f987a9

## Sample

![所有重构手法](/重构.jpg)

## 第二版安利

### 为什么决定再版《重构》？
虽然这本书已经出版了很久，但是在这20年左右时间里，重构的核心思想并没有过时，许多实际的重构手法并没有什么重大变化。让我觉得是时候考虑再版有几个原因：一个原因是，第1版里的代码已经很陈旧了，书里面还有Java.util.Vector。在过去10年中你在工作中如果还在用Java.util.Vector，那么可能你写的代码会有问题；另一个原因是，我也想真正反思，一些重构并非是与面向对象紧耦合在一起的。要知道，Java是一种非常严格的面向对象编程语言，第1版中所有的重构都是基于面向对象的。我想通过再版来说明你可以用任何（编程）语言、在任何环境中、遵循书中提到的范例进行重构，这是我计划再版这本书的另一个理由，也是我再版这本书的源动力。如果这次内容更新得非常到位，可以说再过20年我都不用再修订这本书了。
### 在过去20年中，软件开发领域围绕重构出现了哪些重大变化？
一个重大变化是：我本人和其他人，如Kent Beck等，一直倡导的最佳实践如今比20年前更普遍了。我们确实看到现在开发者经常编写测试用例，大家通过微增量来开发系统。但我认为重构的影响其实应该更广泛，正如我20年前所说的那样。当时我们鼓励大家都接受重构这一概念，但是，在整个行业普及重构仍需要相当长的时间。我希望看到更多人使用我们大力推广的测试法，使用持续集成和持续交付等方法。但涉及上述概念，主客观上我能做的就是尽可能详尽地解释这些技术，并希望这会说服更多人进行尝试，当他们尝到甜头后就会在工作中真正用上这些方法。
### 请简要描述一下《重构》第1版和再版内容的差别。
我去掉了有些重构手法的内容，我觉得它们现在不再那么重要。还有一个例子是：通过重构，我把单向关联改为双向关联，因为我觉得它没有其他内容重要。在新版里我增加了第1版里没有的若干重构手法，先前我错误地认为这些重构手法过于琐碎，不值得花费篇幅谈及，最明显的例子是第1版中没有“搬移语句到函数”这样的内容，但在新版中，我觉得有必要加入。最值得注意的变化是，我尽力以一种不围绕面向对象的方式谈重构，所以其中一些归结为简单的重命名，不再用“提炼方法”，而改名为“提炼函数”诸如此类的。还有一些重构手法，涉及在使用对象或不使用对象之间取舍，因此，如果有重构，就把函数合并成类，也就是提炼一堆函数，将它们合并为一类。这是新版中最为明显的变化。很多人关注到在新版中代码示例我使用的是JavaScript，我不认为这有多要紧的。重构背后的理念和架构适用于任何编程语言。我选择JavaScript，只是因为我觉得它是一种应用广泛的语言。无论你使用哪种语言编程，基本机制都是完全相同的，语言与语言之间固然存在差异，但我认为语言之间的共通之处远比差异多。
### 触发代码重构的原因有哪些？
需要重构代码的原因当然多种多样。首先，当你无法理解代码时，一个明确的迹象是你花了很长时间想弄清楚一些代码的目的或功能。还有一种情况，借用我个人很喜欢的Ward Cunningham的说法：一旦你在脑海中对代码功能有了一定的概念，就要把它从大脑中“拿”出来并放回代码中，这样下次你或其他人再看到这些代码，他们就能真正读懂这些代码。触发重构的另一个因素是开发者想改进代码，但现有代码的架构令改进难度又很大，在这种情况下，重构提升了改进的速度、降低了难度，结构变简单后，改进也就水到渠成了。还是Kent Beck那句话说得好：首先让代码架构易于改变，然后再进行简单的改进。对我而言，下面这些都是触发重构的时机：当你发现代码不够清晰、难以理解时；当你对代码功能有了一些了解，想把这些嵌入代码中时。当你想要改进代码时，比较容易的做法是先进行重构，再添加新功能。
### 基本上人都有一种倾向：东西没坏就不修，更何况重构。对照“我们重构还不到位”的事实，你认为怎样做才能克服这个障碍？
我得承认：我不是一个超有说服力的人。我不会努力说服大家改进，我只是尝试解释该如何做事，希望他们自己领悟并尝试最佳实践。谈到不修改代码时，肯定会涉及需要某种代码库来确保修改代码时可以轻松检测到问题，这就是我们非常重视进行严格测试的原因，因为测试是一种很好的监测机制。还有一些来自项目的技术管理者会向下属说明，改进代码没关系，但只能通过迭代和扩展来写出有效的代码。但是，有时开发者也会固步自封，我就遇到过有些团队的开发者说“哦，我们不该改变”，对上级主管也这样说，而主管会非常诧异，连声说“不对，我真的想重构”。像这种上下级理念完全相反的情况很常见。需要创造一种企业文化，允许大家说：“我们可以回到原点并改进代码。”在测试方面我们有必要的安全基础，这样开发者才能在错误出现时检测到错误。在开发的过程中，一方面你需要为软件添加新功能，另一方面你也需要重构，以确保软件维持健康状态，否则就无法在软件里继续添加新功能。保持两者的平衡非常重要，这要求开发者有良好的判断力。像许多事情一样，良好的判断力确实是个关键元素，但遗憾的是，并没有什么捷径来传授判断力。
### 你认为在面向对象编程向函数式编程的范型转变过程中，你说的机制也完全适用吗？
是的。我认为基本机制不会发生巨大转变。即使你使用面向对象语言工作也是如此。有一等函数很好，可以尝试许多函数式的理念，例如，写软件时大部分函数都具备引用透明性，这在面向对象系统和在函数式系统中都是好事。所以我不像许多人那样在函数式编程和面向对象编程间画出明确界限，我认为两者有很多共同的地方，未必存在巨大差异。我鼓励程序员不要有门户之见，要用综合理念来解决问题。
### 对于最新版《重构》，你有想强调或广而告之的重点内容吗？
有一个重构手法也许值得注意，拆分阶段（split phase）。几年前，当Ken Beck跟我谈拆分阶段的时候，我第一次意识到这也是重构手法。通过这种重构手法，我将大量计算合理分为两个阶段，使用中间数据结构进行通信。其中一个例子是解析拆分阶段可有效地将token从解析中抽离出来，这样就得到了一个可可保存在存储器种的token流，可处理相关字符串、文本字符串。再谈谈重构工具，我和Kent做了很多年了，但我们从来没有意识到工具的重要性；当我们意识到这一点之后，我们感觉重构工具已经无处不在。因为我们已经做了很多年，而这又是可以大书特书的内容。这就是你想做时效性更强的书的原因，因为你想“哎呀，这些内容早该放在20年前的第1版里了”，然后我们就真把这些新内容加到新版中了。
### 商界人士常常认为：如果程序没坏而且没有添加新功能，就不该浪费时间改进。你认为我们该如何说服这些人或表达重构的重要性？
从根本上说，重构不应该是你与商界人士或经理谈论的话题。这么说吧：他们花钱雇我们做好技术工作，而且这其中很大一部分就是使代码库保持健康状态，这样未来就能在代码库上持续添加新功能。如果不重构，严格来说我们就辜负了雇主的期望，因为不重构会导致功能开发速度变慢。从经济角度来看，我们有责任让代码库稳定处于健康状态，重构当然是一种使关键代码库保持健康状态的重要方法，如果不能令代码库保持在健康状态，就相当于我们从客户和上司那里“偷”钱，手段就是降低程序开发或添加新功能的速度。因此，从根本上说，我们有责任进行重构，每当你谈论重构合理性时请记住这个论点。在我看来，你永远不该用诸如“这是我们的职业责任”“这是正确的事情”或 “出于道义理由”等术语，我知道很多人都喜欢用这套说法，而当你滥用术语时，你已经迷失了。重构的唯一原因是经济原因，重构的目的是更快地增加更多功能，以便更及时地响应各方需求的变化，而经济原因才是重构的底层原因。顺便说一句：这也是明智的专业态度才是正途的原因，因为老板花钱请开发人员用代码快速生成功能，我们也该站在这个立场上考虑重构问题。但严格来说，对管理者或企业而言，快速开发或新增功能，或者使代码库保持健康等因素并不重要。我的意思是，他们付钱给开发人员搞软件开发正是为了处理这些问题。
### 重构思维是否可以超越代码，应用到其他层面？
绝对可以。重构的关键是理念：如何进行最细微的改变，而不是努力搞大的变化尝试，并弄清楚如何做到这一点。通过重构就会发生很多细小的变化，然后将这些变化串联起来，这就是重构思维适用于这种情况的核心。我们如何将一个大变化拆分为许多小变化，又在尽可能多进行细微变化的同时，不改变系统的整体表现，然后随时间推移，反复练习并思考如何进行拆分。我书中的内容就是我通过重构框架思考问题的体验，尝试各种重构手法并做出决定。书里有一整套机制让我能够高效地进行重构，但主要时通过实践进行重构。你尝试了不同的重构手法，然后找出哪个重构手法能生成理想序列，你尝试识别出这种重构手法，同样的逻辑也适用于更广泛的层面。
### 重构到哪种地步你会考虑完全重写代码？
还是那句话：说到底都是个人判断，很难给出任何一个有共通性的同类情况。也就是说，让你考虑重写代码肯定有迹象，比如说：你在某个平台上没法推进项目了，原因也许是编程语言太老了，或平台环境太老了，不再适用于当前的情况，然后，在这种情况下，只是进行重构作用不大，你不妨重写代码，创造一个更现代和更适合的环境。另一件会推动你重写而不是重构的事情可能是缺乏测试，因为如果不测试，重构会变得困难得多。当然，无论你是重写还是重构，进行测试都是一件好事。如果你可以构建一组测试，目的是检测现有行为，就会大大降低重写的难度以及重构的难度，所以无论哪种方式，测试都是一条很好的路线。这么说吧：我认为没有任何迹象称得上是应该重写或重构的明确的黄金指标，我猜想大多数人更倾向于重写而不是重构，而这只是个人感觉，背后并没有任何强有力的证据。
### 除了阅读《重构》这本书外，你对刚入行的开发者有什么其他建议吗？
最重要的事情之一就是实践。重构就像软件开发的大多数工作一样：除了动手做，别无他法。找到一位能手把手教你改进的导师是最理想的。显然这本书旨在尽可能地帮助大家，但如果有人能给予手把手的指导，效果肯定更好，当然这也是本书的目标之一。这本书肯定能帮助那些初次接触重构概念的人，但它也能帮助那些了解重构的人分享相关技能。可以说，这样的书有两种受众：直接学习怎样重构的初学者，以及希望传授重构经验的人。书中很大一部分内容也可以帮助读者传授重构知识并提高教学效率
### 再给读者一些关于这本书的阅读建议吧。
我希望人们觉得新版书对自己的工作有帮助，在重构方面最重要的事情就是具体操作，对吧？所以，你必须反复实践，必须与团队一起在项目中使用重构。或许这听起来有点儿可怕，如果你之前没怎么做过重构，请记住重构的要义就是小步骤改进，确保你频繁提交。如果出了什么问题，你只需回滚到先前的提交记录上，这就会降低重构的压力。我的意思是，重构肯定不会给你带来太坏的影响，因为大不了你就回滚呗，这就是版本控制系统的用途。所以，赶紧上手重构吧，操作才是关键。
